<!DOCTYPE html>
<html>
<head>
	<title>分型山脉</title>
	<meta charset="utf-8">
	<meta name='viewport' content="width=device-width,initial-scale=1.0,user-scalable=no">
	<script id='vertex-shader' type='x-shader/x-vertex'>
		attribute vec4 vPosition;
		void main(){
			gl_Position=vPosition;
			gl_PointSize=1.0;
		}
	</script>
	<script id='fragment-shader' type="x-shader/x-fragment">
		precision mediump float;
		void main(){
			gl_FragColor=vec4(1.0,0.0,0.0,1.0);
		}
	</script>
	<script src="../Common/webgl-utils.js"></script>
	<script src="../Common/initShaders.js"></script>
	<script src="../Common/MV.js"></script>
</head>
<body>
	<!-- 可参考基于分形算法的手绘山体生成技术研究 -->
	<!-- 三维分形地形真实感绘制 -->
	<canvas id='gl-canvas' width="512" height="512"></canvas>
	<script  type='text/javascript'>
			var gl;
			var points=[];
			var NumTimesToSubdivide=6;
			var rdm=[1];
			window.onload=function init(){
				var canvas=document.getElementById('gl-canvas');
				for(var i=0;i<NumTimesToSubdivide;i++){//随机数
					var a=Math.random();
					if(a>=0.5){
						rdm.push(1);
					}else{
						rdm.push(-1);
					}
				}
				gl=WebGLUtils.setupWebGL(canvas);
				if(!gl){
					alert("WebGl isn't available");
				}
				var vertices=[
					vec2(0,0.3),
					vec2(-0.9,-1.0),
					vec2(0.8,-0.9)
				];
				divideTriangle(vertices[0],vertices[1],vertices[2],NumTimesToSubdivide);
				gl.viewport(0,0,canvas.width,canvas.height);
				gl.clearColor(1.0,1.0,1.0,1.0);
				var program=initShaders(gl,"vertex-shader","fragment-shader");
				gl.useProgram(program);

				//把数据加载到GPU中
				var bufferId=gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER,bufferId);
				gl.bufferData(gl.ARRAY_BUFFER,flatten(points),gl.STATIC_DRAW);

				var vPosition=gl.getAttribLocation(program,"vPosition");
				gl.vertexAttribPointer(vPosition,2,gl.FLOAT,false,0,0);
				gl.enableVertexAttribArray(vPosition);
				render();
			}

			function divideTriangle(a,b,c,count){
				var dis_ab=Math.pow(((a[0]-b[0])*(a[0]-b[0])+(a[1]-b[1])*(a[1]-b[1])),0.5);
				var dis_ac=Math.pow(((a[0]-c[0])*(a[0]-c[0])+(a[1]-c[1])*(a[1]-c[1])),0.5);
				var dis_bc=Math.pow(((b[0]-c[0])*(b[0]-c[0])+(b[1]-c[1])*(b[1]-c[1])),0.5);
				var p=mix(a,b,0.5),q=mix(a,c,0.5),s=mix(b,c,0.5);
				var x1,y1,x2,y2,x3,y3;
				var p_plus,q_plus,s_plus;
				var t=rdm[count];
				var r1=t*0.25*Math.pow(2,-count*0.02);
				x1=p[0];
				y1=p[1]+r1*dis_ab;
				x2=q[0];
				y2=q[1]+r1*dis_ac;
				x3=s[0];
				y3=s[1]+r1*dis_bc;
				p_plus=vec2(x1,y1);
				q_plus=vec2(x2,y2);
				s_plus=vec2(x3,y3);
				if(count==0){
					points.push(a,p_plus,p_plus,q_plus,q_plus,a);
					points.push(b,s_plus,s_plus,p_plus,p_plus,b);
					points.push(p_plus,s_plus,s_plus,q_plus,q_plus,p_plus);
					points.push(c,q_plus,q_plus,s_plus,s_plus,c);
				}else{
					--count;
					divideTriangle(a,p_plus,q_plus,count);
					divideTriangle(p_plus,b,s_plus,count);
					divideTriangle(p_plus,s_plus,q_plus,count);
					divideTriangle(q_plus,s_plus,c,count);
				}
			}
			function render(){
				gl.clear(gl.COLOR_BUFFER_BIT);
				gl.drawArrays(gl.LINES,0,points.length);
			}
	</script>
</body>
</html>


































