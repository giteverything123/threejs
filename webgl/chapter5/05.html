<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>练习题5.16</title>
    <style>
        *{
            margin:0;
            padding:0;
            box-sizing: border-box;
        }
    </style>
</head>
<body>
    <canvas id="webglcanvas"></canvas>
    <script id="vertex-shader" type="x-shader/vertex-shader">
        attribute vec4 vposition;
        attribute vec4 vcolor;
        uniform mat4 modelMatrix;
        uniform mat4 projectMatrix;
        varying vec4 fcolor;
        void main(){
            fcolor=vcolor;
            gl_Position=projectMatrix*modelMatrix*vposition;

        }
    </script>
    <script id="fragment-shader" type="x-shader/fragment-shader">
        precision mediump float;
        varying vec4 fcolor;
        void main(){
            gl_FragColor=fcolor;
        }
    </script>
    <script src="../Common/webgl-utils.js"></script>
	<script src="../Common/initShaders.js"></script>
    <script src="../Common/MV.js"></script>

    <script>
        window.onload=()=>{
            let canvas=document.getElementById('webglcanvas');
            let WIDTH=document.body.offsetWidth;
            canvas.width=WIDTH;
            canvas.height=WIDTH;
            let gl=WebGLUtils.setupWebGL(canvas);
            if(!gl){
                alert('您的浏览器不支持webgl功能');
            }
            let program=initShaders(gl,'vertex-shader','fragment-shader');
            gl.useProgram(program);
            gl.viewport(0,0,canvas.width,canvas.height);
            gl.clearColor(1.0,1.0,1.0,1.0);
            gl.enable(gl.DEPTH_TEST);
            //先定义外面的盒子，
            let outboxpoints=[
                [-0.5,0.5,0.5],
                [-0.5,-0.5,0.5],
                [0.5,-0.5,0.5],
                [0.5,0.5,0.5],
                [0.5,-0.5,-0.5],
                [0.5,0.5,-0.5],
                [-0.5,0.5,-0.5],
                [-0.5,-0.5,-0.5]
            ];
            //再定义里面的盒子
            let innerboxpoints=[
                [-0.5/4,0.5/4,0.5/4],
                [-0.5/4,-0.5/4,0.5/4],
                [0.5/4,-0.5/4,0.5/4],
                [0.5/4,0.5/4,0.5/4],
                [0.5/4,-0.5/4,-0.5/4],
                [0.5/4,0.5/4,-0.5/4],
                [-0.5/4,0.5/4,-0.5/4],
                [-0.5/4,-0.5/4,-0.5/4]
            ];
            let colors=[
                [0.0,0.0,0.0], // v0 Black
				[1.0,0.0,1.0],  // v1 Magenta
				[1.0,0.0,0.0],  // v2 Red
				[1.0,1.0,0.0],  // v3 Yellow
				[0.0,1.0,0.0],  // v4 Green
				[0.0,1.0,1.0],  // v5 Cyan
				[0.0,0.0,1.0],  // v6 Blue
                [1.0,1.0,1.0],  // v7 White
            ];
            let pointsArray=[];//这是存储定点的数组
            let colorsArray=[];//这是存储颜色的数组
            let quad=(a,b,c,d,points)=>{//定义一个函数使得每个面只有一种颜色
                pointsArray.push(points[a]);
                colorsArray.push(colors[a]);
                pointsArray.push(points[b]);
                colorsArray.push(colors[a]);
                pointsArray.push(points[c]);
                colorsArray.push(colors[a]);
                pointsArray.push(points[a]);
                colorsArray.push(colors[a]);
                pointsArray.push(points[c]);
                colorsArray.push(colors[a]);
                pointsArray.push(points[d]);
                colorsArray.push(colors[a]);
            }
            let cube=(arr)=>{
                quad(1,2,3,0,arr);//生成第1个面
                quad(2,4,5,3,arr);//生成第2个面
                // quad(3,5,6,0,outboxpoints);//第3个面,这个面不用生成
                quad(4,5,6,7,arr);//生成第4个面
                quad(7,1,2,4,arr);//生成第5个面
                quad(6,7,1,0,arr);//生成第6个面
            }
            let modelMatrixLoc=gl.getUniformLocation(program,'modelMatrix');
            let eye=[-1,2,1];
            let at=[0,0,0];
            let up=[0,1,0];
            let modelMatrix=lookAt(eye,at,up);
            let modelMatrix2=lookAt(eye,at,up);
            let theta=0;
            let projectMatrixLoc=gl.getUniformLocation(program,'projectMatrix');
            let projectMatrix=ortho(-2,2,-2,2,-4,4);
            gl.uniformMatrix4fv(projectMatrixLoc,false,flatten(projectMatrix));
            //定义一个渲染函数不断的渲染
            let render=()=>{
                pointsArray=[];
                colorsArray=[];
                cube(outboxpoints);//调用生成外面的盒子
                let buffer1=gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER,buffer1);
                gl.bufferData(gl.ARRAY_BUFFER,flatten(pointsArray),gl.STATIC_DRAW);
                let vposition=gl.getAttribLocation(program,'vposition');
                gl.vertexAttribPointer(vposition,3,gl.FLOAT,false,0,0);
                gl.enableVertexAttribArray(vposition);
                let colorbuffer=gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER,colorbuffer);
                gl.bufferData(gl.ARRAY_BUFFER,flatten(colorsArray),gl.STATIC_DRAW);
                let vcolor=gl.getAttribLocation(program,'vcolor');
                gl.vertexAttribPointer(vcolor,3,gl.FLOAT,false,0,0);
                gl.enableVertexAttribArray(vcolor);
                gl.bindBuffer(gl.ARRAY_BUFFER,null);
                gl.uniformMatrix4fv(modelMatrixLoc,false,flatten(modelMatrix));
                gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLES,0,pointsArray.length);
                pointsArray=[];
                colorsArray=[];
                cube(innerboxpoints);//这是第二个正方形
                let buffer2=gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER,buffer2);
                gl.bufferData(gl.ARRAY_BUFFER,flatten(pointsArray),gl.STATIC_DRAW);
                gl.vertexAttribPointer(vposition,3,gl.FLOAT,false,0,0);
                gl.enableVertexAttribArray(vposition);
                let colorbuffer2=gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER,colorbuffer2);
                gl.bufferData(gl.ARRAY_BUFFER,flatten(colorsArray),gl.STATIC_DRAW);
                gl.vertexAttribPointer(vcolor,3,gl.FLOAT,false,0,0);
                gl.enableVertexAttribArray(vcolor);
                 gl.bindBuffer(gl.ARRAY_BUFFER,null);
                //让里面的方块不断的绕着y轴旋转
                theta++;
                theta=Math.PI/180*theta;//转为角度
                let my=mat4([
                    Math.cos(theta),0,Math.sin(theta),0,
                    0,1,0,0,
                    -Math.sin(theta),0,Math.cos(theta),0,
                    0,0,0,1
                ]);
                modelMatrix2=mult(modelMatrix2,my);
                gl.uniformMatrix4fv(modelMatrixLoc,false,flatten(modelMatrix2));
                gl.drawArrays(gl.TRIANGLES,0,pointsArray.length);
                //下面定义第1个光源
                let light01=[0,0,0.25];
                let m=mat4();
                m[3][2]=1/0.5;
                m[3][3]=0.0;
                modelMatrix2=mult(modelMatrix2,translate(light01[0],light01[1],light01[2]));
                modelMatrix2=mult(modelMatrix2,m);
                modelMatrix2=mult(modelMatrix2,translate(-light01[0],-light01[1],-light01[2]));
                gl.uniformMatrix4fv(modelMatrixLoc,false,flatten(modelMatrix2));
                gl.drawArrays(gl.TRIANGLES,0,pointsArray.length);
                //把
                requestAnimationFrame(render);
            }
            render();
        }
    </script>

</body>
</html>